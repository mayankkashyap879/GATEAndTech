## File System

The project uses a monorepo managed by Turbo Repo or Nx and divides client and server functionality into clearly scoped folders. This allows cross‑package sharing and isolates concerns. The high‑level structure is as follows:

```
/
├── apps/
│   └── web/                     # Next.js 14 (App Router) application
│       ├── app/                 # App Router pages (route segments)
│       │   ├── (auth)/          # Layout & pages for login/signup, protected pages
│       │   ├── dashboard/       # Role-specific dashboards (student, moderator, admin)
│       │   ├── test-player/     # GATE-like test player UI
│       │   ├── blog/            # Public blog pages
│       │   ├── api/             # API routes (/api/auth, /api/questions, etc.)
│       │   └── layout.tsx       # Root layout using Tailwind & Radix
│       ├── components/          # App-specific React components (forms, navbars)
│       ├── contexts/            # React Context providers (auth, theme)
│       ├── hooks/               # Custom hooks (useExamState, usePermissions)
│       ├── styles/              # Global Tailwind directives and CSS variables
│       ├── public/              # Static assets (images, icons)
│       └── tests/               # Frontend unit and integration tests (Vitest, RTL)
├── packages/
│   ├── ui/                      # Reusable component library (Radix-wrapped components)
│   │   ├── Button/
│   │   │   ├── Button.tsx
│   │   │   └── Button.test.tsx
│   │   ├── Dialog/
│   │   ├── Chart/
│   │   └── index.ts
│   ├── domain/                  # Business domain logic shared by front and back end
│   │   ├── schemas/             # Zod schemas for validation
│   │   │   ├── user.schema.ts
│   │   │   ├── question.schema.ts
│   │   │   ├── test.schema.ts
│   │   │   └── ...
│   │   ├── abilities/           # CASL ability definitions (RBAC rules)
│   │   ├── constants/           # Enum definitions (roles, permissions, question types)
│   │   ├── types.ts             # Shared TypeScript types
│   │   └── index.ts
│   ├── db/                      # Prisma client and migrations
│   │   ├── prisma/
│   │   │   ├── schema.prisma    # DB schema definitions
│   │   │   └── migrations/      # Migration files
│   │   ├── seed.ts              # Seed script for development
│   │   ├── client.ts            # Prisma client instantiation with logging
│   │   └── index.ts
│   ├── worker/                  # Background job processors (BullMQ)
│   │   ├── jobs/
│   │   │   ├── analytics.job.ts # Processes analytics aggregation
│   │   │   ├── email.job.ts     # Sends scheduled emails
│   │   └── queue.ts             # BullMQ queue setup
│   └── types/                   # Generated types (e.g., Razorpay webhooks, PostHog)
├── .github/
│   ├── workflows/               # GitHub Actions CI/CD definitions
│   └── CODEOWNERS
├── docker/
│   ├── Dockerfile.web           # Container for Next.js app
│   ├── Dockerfile.worker        # Container for background workers
│   └── docker-compose.yml       # Local composition of services (Postgres, Redis)
├── .env.example                 # Example environment variables (no secrets)
├── package.json                 # Root dependencies and scripts
├── turbo.json                   # Task pipeline definitions
└── README.md
```

Each folder is version‑controlled, unit‑tested, and linted according to the global coding rules. API routes live in `apps/web/app/api` because Next.js App Router uses file‑system routing. Reusable UI components live in `packages/ui` and are documented via Storybook. Business logic and validation schemas live in `packages/domain`. Database migrations and Prisma client are centralised in `packages/db`. Background jobs live in `packages/worker`. The worker is a separate process (deployed on DigitalOcean Functions or a worker container) that listens to BullMQ queues.

## Feature Specifications

### 1. Account & Identity

#### Feature goal

Provide secure account creation, login, theme preference, and multi‑provider authentication (email/password, Google, GitHub) for students, moderators and admins. Support optional two‑factor authentication (2FA) and persistent theme selection.

#### API relationships

* Utilises NextAuth.js providers for OAuth flows. The callback URIs must include the full domain and end in `/api/auth/callback/{provider}`.
* Stores user profiles, roles and 2FA settings in PostgreSQL via Prisma.
* Interacts with PostHog for analytics events (signup, login), but only sends anonymous or hashed identifiers.
* Calls Razorpay APIs indirectly when verifying purchases, but not in the core identity flow.

#### Detailed feature requirements

1. **Sign‑Up & Login**

   * Email/password registration with email verification. Users provide name, email, password (Argon2 hashed).
   * OAuth via Google and GitHub. During provider setup, ensure "Authorized redirect URIs" include the full domain and callback path; configure providers with `clientId` and `clientSecret` environment variables.
   * When signing in with Google/GitHub, automatically create a user record if none exists. Map provider IDs to user accounts.
   * If using Google, restrict to verified emails and optionally a specific domain by checking `profile.email_verified` and domain suffix.

2. **Two‑Factor Authentication (2FA)**

   * Optional per‑user; use authenticator apps (TOTP) like Google Authenticator.
   * Provide routes to enable/disable 2FA, generate QR codes, verify tokens. Store hashed secrets per user.

3. **Theme Preference**

   * Users can choose dark, light or system theme. Persist selection in the user profile table.
   * React context reads the preference and sets `data-theme` attribute accordingly.

4. **Session & Token Management**

   * Use JWT sessions (NextAuth default) stored in cookies with HTTP‑only, Secure flags.
   * Refresh tokens for OAuth providers stored encrypted in DB (if required).
   * Session expiry configurable (e.g., 30 days).

5. **User Profile**

   * Endpoint to view and edit user profile (name, avatar, theme, 2FA status).
   * Prevent editing email or provider ID; require re‑auth for sensitive actions (email change, password reset).

6. **Password Reset**

   * Generate signed, time‑limited tokens emailed via SendGrid or similar.
   * Provide pages to request reset and set new password.

#### Detailed implementation guide

##### System Architecture Overview

* **Authentication Layer**: Use NextAuth.js configured in `/apps/web/app/api/auth/[...nextauth]/route.ts`. Providers: Email (with SMTP configured), GoogleProvider and GitHubProvider with client secrets stored in DO secrets. The example code from NextAuth docs shows how to configure Google provider with environment variables.
* **2FA Service**: Implement TOTP using `otplib`. Store hashed TOTP secret in a dedicated table or column on `User`. Provide an API route to generate QR codes and verify tokens.
* **Session Management**: Rely on NextAuth's JWT session by default; persist sessions in Postgres for long‑lived sessions if needed.
* **UI**: Sign‑up and login forms built with React‑Hook‑Form and Zod validations; handle provider sign‑in via NextAuth’s `signIn()` method.

##### Database Schema Design

* **User** table (`users`):

  * `id` (UUID, primary key)
  * `name` (string)
  * `email` (string, unique, indexed)
  * `email_verified_at` (timestamp)
  * `password_hash` (string, nullable)
  * `provider` (enum: 'credentials', 'google', 'github')
  * `provider_id` (string, nullable, unique when provider ≠ 'credentials')
  * `theme` (enum: 'light', 'dark', 'system')
  * `twofa_enabled` (boolean)
  * `twofa_secret` (string, nullable, stored encrypted)
  * `role_id` (FK to `roles.id`)
  * timestamps (`created_at`, `updated_at`)

* **Roles** table (`roles`): Contains role definitions (student, moderator, admin) and references to `permissions`.

* **Sessions** table (if using NextAuth DB sessions): `id`, `user_id`, `expires`, `session_token`.

* **VerificationTokens** table: For password reset and email verification.

##### Comprehensive API Design

* **POST /api/auth/register**

  * Request: `{ name, email, password }`.
  * Validates via Zod; returns 400 on invalid input.
  * Hashes password with Argon2id; creates user with role `student`.
  * Triggers verification email via background job.
  * Response: `{ success: true }`.

* **POST /api/auth/login**

  * Handled by NextAuth; for credentials, verify password via Argon2id.
  * On success, sets session cookie; returns redirect URL.

* **GET /api/auth/csrf**: Provided by NextAuth.

* **POST /api/auth/2fa/enable**

  * Authenticated route; generates TOTP secret and returns QR code string.

* **POST /api/auth/2fa/verify**

  * Verifies token; on success sets `twofa_enabled = true` and stores secret.

* **PUT /api/users/me**

  * Authenticated; body may include `name`, `theme`; uses CASL to check permission.

* **POST /api/auth/password-reset-request**

  * Body: `{ email }`; creates token and sends email.

* **POST /api/auth/password-reset**

  * Body: `{ token, new_password }`; verifies token, updates password.

##### Frontend Architecture

* **Component hierarchy**:

  * `AuthProvider`: wraps Next.js with `SessionProvider` for NextAuth.
  * `AuthLayout`: layout under `/app/(auth)` containing sign‑in and sign‑up pages.
  * `SignUpForm`, `LoginForm`: forms validated with react-hook-form & zod.
  * `OAuthButtons`: triggers `signIn('google')`/`signIn('github')`.
  * `ProfilePage`: fetches user via `/api/users/me`.
  * `TwoFactorSettings`: toggles 2FA; displays QR code.

* **State management**: Use `SessionProvider` from NextAuth for auth state; store theme in context and persist to `localStorage` and DB.

* **Routing**: Use Next.js App Router; dynamic route segments for `/auth` pages and protected layouts for `/dashboard`.

##### Detailed CRUD Operations

1. **User CRUD**

   * *Create*: Sign‑up or OAuth sign‑in. Validate uniqueness of email, apply password rules (min length, complexity).
   * *Read*: `GET /api/users/me` returns current user. Admin endpoint `GET /api/users?cursor=` with pagination and role filter.
   * *Update*: `PUT /api/users/:id` restricted to owner or admin; allows updating name, theme, role (admin only), and toggling 2FA.
   * *Delete*: Soft delete on admin only; sets `deleted_at` timestamp and revokes sessions. Hard delete via scheduled job after retention period.

2. **Session CRUD**

   * Managed by NextAuth; sessions created on login, invalidated on logout or expiry.

##### User Experience Flow

* New user visits `/signup`; enters details or clicks Google/GitHub button. On sign‑up, receives verification email; after verifying, automatically logged in.
* Returning user visits `/login`; enters credentials or uses OAuth. If 2FA enabled, prompted for TOTP code.
* After login, user redirected to dashboard based on role.
* User can open profile settings to change name, theme or enable 2FA.

##### Security Considerations

* Use Argon2id for password hashing; enforce password complexity.
* Use HTTPS; `Secure` and `HttpOnly` flags on cookies.
* Use NextAuth’s built‑in CSRF protection for credentials sign‑in.
* Restrict OAuth callback URIs to whitelisted domains.
* Rate‑limit login and sign‑up endpoints via Redis.
* Validate all inputs with Zod; sanitise user‑generated content.

##### Testing Strategy

* **Unit tests**: Validate Zod schemas for user input; test password hashing and TOTP verification logic.
* **Integration tests**: Use `next-auth` test utilities to test sign‑in flows; test protected API routes with supertest and mocks.
* **E2E tests**: Use Cypress to simulate sign‑up, login, 2FA flows, theme switching.
* **Performance tests**: Ensure login endpoint responds <200 ms under load.

##### Data Management

* Use PostgreSQL `unique` index on email/provider\_id.
* Use Redis for short‑lived verification tokens to speed up lookup.
* Purge soft‑deleted users after retention period.
* Use cursor‑based pagination for admin list of users (limit 50).

##### Error Handling & Logging

* Wrap all API routes with error handlers returning unified error envelopes.
* Log failed login attempts and password reset requests via Pino with anonymised email hash.
* Use Sentry to capture unexpected errors.

---

### 2. Role-Based Access Control (RBAC)

#### Feature goal

Allow administrators to define roles and assign fine‑grained permissions that control access to resources (questions, tests, analytics, comments). Enforce these permissions both on the client (React) and server (API routes).

#### API relationships

* Utilises CASL for ability definitions and permission checks in React and server.
* Relies on the `roles` and `permissions` tables in Postgres.
* Interacts with every other feature via middleware that checks user abilities before allowing actions.

#### Detailed feature requirements

1. **Role Creation & Management**

   * Admin can create arbitrary roles (e.g., “subject‑expert”, “content‑editor”) with a set of permissions.
   * Roles can be created, updated, deleted. Deleting a role reassigns associated users to a fallback role or blocks them.

2. **Permission Bundles**

   * Permissions are granular (e.g., `create:question`, `update:question`, `publish:test`, `view:analytics`).
   * Admin can toggle individual permissions per role.

3. **Audit Log**

   * Every change to roles and permissions is recorded with user ID, timestamp, old/new values.

4. **Authorization Enforcement**

   * On the client, components should hide or disable actions if the user cannot perform them.
   * On the server, API routes verify abilities using CASL’s `Ability.can()`.

#### Detailed implementation guide

##### System Architecture Overview

* **CASL Setup**: Define a central `defineAbilitiesFor(user)` function in `/packages/domain/abilities/`. It reads the user’s role and constructs a CASL Ability instance listing allowed actions and conditions.
* **Middleware**: Implement an Express‑like middleware wrapper for Next.js API routes and server components. Before executing handler logic, call `ability.can(action, subject)`; return 403 if not permitted.
* **React Components**: Provide `Can` component that receives `IAbility` and renders children conditionally.

##### Database Schema Design

* **Roles** (`roles`):

  * `id` (UUID)
  * `name` (string, unique)
  * `description` (string)
  * `created_at`, `updated_at`

* **Permissions** (`permissions`):

  * `id` (UUID)
  * `action` (string) e.g., 'create', 'read', 'update', 'delete', 'publish'
  * `subject` (string) e.g., 'Question', 'Test', 'Comment'
  * `conditions` (JSON, nullable) for attribute‑based control
  * `created_at`, `updated_at`

* **RolePermissions** (`role_permissions`):

  * `role_id` (FK to roles)
  * `permission_id` (FK to permissions)
  * `granted` (boolean)

* **AuditLogs** (`audit_logs`):

  * `id` (UUID)
  * `actor_id` (FK to users)
  * `action` (string)
  * `target` (string)
  * `changes` (JSON)
  * `created_at`

##### Comprehensive API Design

* **GET /api/roles**

  * Returns paginated list of roles with their permissions.
  * Query parameters: `cursor`, `limit`, `search`.

* **POST /api/roles**

  * Body: `{ name, description, permissions: [ { action, subject } ] }`.
  * Requires admin ability `create:role`.

* **PUT /api/roles/\:id**

  * Updates role name or permissions. Requires `update:role`.
  * Body includes diff of permissions; update `role_permissions` accordingly.

* **DELETE /api/roles/\:id**

  * Requires `delete:role`. Soft delete role and reassign users.

* **GET /api/permissions**

  * Returns static list of possible permissions.

* **POST /api/users/\:id/role**

  * Assigns a role to a user. Only admin can call.

* **GET /api/audit-logs**

  * Returns changes to roles/permissions with filtering.

##### Frontend Architecture

* **Role Management Dashboard**: Under admin dashboard, show table of roles and counts of users per role. Provide actions to create/edit/delete roles via modal dialogues.
* **Permission Editor**: When editing a role, present a grid of subjects vs actions with checkboxes. Save changes via API.
* **Audit Log Page**: Show list of role changes with diff details, sortable by date.

##### Detailed CRUD Operations

* *Roles*

  * **Create**: Validate unique `name`; create role and insert `role_permissions` entries.
  * **Read**: `GET /api/roles`; support search by name, pagination.
  * **Update**: Update role’s name and description; compute added and removed permissions; update pivot table; record audit log.
  * **Delete**: Soft delete (set `deleted_at`); optionally assign to fallback role.

* *Permissions*

  * These are mostly static. Provide seeding script to insert base permissions.
  * CRUD for permissions reserved for super‑admins; usually not changed.

##### User Experience Flow

* Admin navigates to "Roles & Permissions" page. They see existing roles and counts.
* Clicking "Create Role" opens a form with name and checkboxes for permissions.
* After creation, role appears in the list and can be assigned to users via "User Management" page.
* When editing a role, toggling permissions updates the grid; on save, diff is recorded in audit log.

##### Security Considerations

* Only users with `manage:roles` permission can access role API routes.
* Validate inputs; ensure a role always has at least one permission.
* Prevent deletion of the default admin role.
* Logging: record actor, time, and changes.

##### Testing Strategy

* Unit tests for ability definitions: verify that each role has correct permissions.
* Integration tests: test API routes with different user roles.
* E2E tests: simulate admin creating a role and verifying new abilities take effect.

##### Data Management

* Use `deleted_at` fields on `roles` and cascade deletion on `role_permissions` only when hard deleting.
* Provide migration script to seed default roles and permissions.

##### Error Handling & Logging

* Return 403 for unauthorized attempts.
* Use `audit_logs` table to track changes.
* Surface friendly error messages in the UI (“You lack permission to perform this action.”).

---

### 3. Question Authoring & Content Management

#### Feature goal

Allow moderators to create, import, edit, and publish questions with LaTeX equations, code snippets and media. Provide a rich editor with MDX/KaTeX support and versioning. Support bulk import via CSV/QTI/Markdown.

#### API relationships

* CRUD operations on questions stored in Postgres via Prisma.
* File uploads to DigitalOcean Spaces via signed URLs.
* Real‑time duplication detection via backend service (e.g., using full‑text search).
* LaTeX rendered with KaTeX in the client; code snippets highlighted via `prismjs`.
* Bulk import triggers background jobs in `packages/worker`.

#### Detailed feature requirements

1. **Question Editor**

   * Rich text and markdown hybrid editor using MDX v2. Users can embed LaTeX (rendered by KaTeX), images (uploaded to Spaces), and code blocks.
   * Autosave drafts; maintain version history; show diff between versions.
   * Duplicate detection: on save, compute hash of question text and search similar questions; warn if duplicates found.

2. **Question Metadata**

   * Fields: title, body, options (A/B/C/D, multi‑correct), correct answer(s), explanation, difficulty (easy/medium/hard), subject, tags, time limit (in seconds), status (draft/published).
   * Each question belongs to a "question bank" owned by a moderator.

3. **Bulk Import**

   * Support CSV and QTI (IMS Question & Test Interoperability). Provide mapping wizard for columns to fields.
   * On upload, parse file, validate each row against schema, and insert.
   * If any row fails validation, present errors with row numbers.
   * Use a background job to process imports and send progress notifications.

4. **Versioning & Audit**

   * Every edit creates a new version record with diff; maintain revision history.
   * Allow moderators to revert to previous versions.

5. **Search & Filter**

   * Moderators can search by subject, tag, difficulty, and full‑text of question.
   * Provide filters for published/draft.

6. **Permissions**

   * Only users with `create:question` can create questions; `update:question` to edit; `delete:question` to soft delete; `publish:question` to publish.

#### Detailed implementation guide

##### System Architecture Overview

* **Editor Front‑end**: Use `@mdx-js/react` for MDX editing and preview. Combine `react-hook-form` with a custom `MDXEditor` component. Use `react-dropzone` for image uploads.
* **Storage**: Use DigitalOcean Spaces to store images and media. Obtain pre‑signed upload URLs from the server (`POST /api/storage/sign`). After upload, store the returned URL in the question body.
* **Backend**: Implement question CRUD in Next.js API routes at `/api/questions`. Validate incoming data with Zod schemas defined in `/packages/domain/schemas/question.schema.ts`. Use Prisma to persist. Use `pg_trgm` extension for full‑text search and similarity detection.

##### Database Schema Design

* **Questions** (`questions`):

  * `id` (UUID)
  * `moderator_id` (FK to users)
  * `title` (string)
  * `body` (text, MDX)
  * `options` (JSON array of option objects with `label`, `value`)
  * `correct_answers` (JSON array of option IDs)
  * `explanation` (text, MDX)
  * `difficulty` (enum)
  * `subject_id` (FK to subjects)
  * `tags` (text array)
  * `time_limit` (integer, seconds)
  * `status` (enum: 'draft', 'published', 'archived')
  * `version_of` (nullable FK to `questions.id` of parent version)
  * `version_number` (integer)
  * `created_at`, `updated_at`

* **QuestionVersions** (optional separate table) storing historic versions; or use `version_of` and `version_number` on the same table.

* **Subjects** (`subjects`): `id`, `name`, `slug`, `created_at`.

* **QuestionBank** (`question_banks`): optional grouping by bank; holds `id`, `name`, `owner_id`.

##### Comprehensive API Design

* **GET /api/questions**

  * Query params: `cursor`, `subject_id`, `difficulty`, `tags`, `status`, `search`, `moderator_id`, `limit`.
  * Returns paginated list with version info (latest version only).

* **GET /api/questions/\:id**

  * Returns full question with MDX body and options.
  * If `version` query param provided, returns specified version.

* **POST /api/questions**

  * Body: question data; requires `create:question` ability.
  * Handles image uploads via signed URLs separately.
  * Returns created question ID.

* **PUT /api/questions/\:id**

  * Requires `update:question`; checks if user is owner or has global permission.
  * Creates new version record with incremented version number; sets current version.

* **DELETE /api/questions/\:id**

  * Soft deletes; sets `status = 'archived'`. Requires `delete:question`.

* **POST /api/questions/import**

  * Accepts a file upload (CSV/QTI).
  * Parses and enqueues a job (BullMQ) to insert questions.
  * Returns job ID; progress polled via `/api/jobs/:id`.

* **GET /api/questions/\:id/versions**

  * Returns list of versions with diff metadata.

##### Frontend Architecture

* **QuestionEditorPage**: Route under `/dashboard/moderator/question/edit/:id` or `/create`. Contains:

  * Side panel: metadata fields (subject, tags, difficulty).
  * Editor area: MDX editor for question body and explanation; options builder.
  * Toolbar: Save draft, Publish, Version history.
* **QuestionListPage**: Table with filters and search bar. Uses server actions to fetch paginated data.
* **ImportWizard**: Steps: select file, map columns, preview data, confirm import.
* **VersionHistoryModal**: Show list of versions; clicking opens diff viewer (using `react-diff-viewer`).

##### Detailed CRUD Operations

* *Questions*

  * **Create**: Validate title, at least two options, at least one correct answer. Strip any embedded scripts from MDX. Set `version_number = 1` and `version_of = NULL`.
  * **Read**: Support filtering and full‑text search. Use `ILIKE` or `to_tsquery` for PostgreSQL search.
  * **Update**: On edit, insert a new row referencing previous version; set `version_of` to original question ID. Optionally maintain revision diff.
  * **Delete**: Soft delete by marking status. Hard delete only if no tests reference the question.
* *Bulk Import*

  * Validate file format, parse rows. Provide mapping UI for fields. For each row, call the create endpoint or handle within job. On success, return summary of imported and failed rows.

##### User Experience Flow

* Moderator goes to "Create Question". They fill metadata fields, write question using rich editor. They can upload images; the editor shows progress.
* On clicking "Save Draft", the question is validated, a new version is saved, and they remain on the page. "Publish" sets status to `published` and makes question available for test‑series.
* In the question list, moderator can search by tag or subject; clicking a row opens the editor in view/edit mode. Version history is accessible via modal.
* For bulk import, moderator selects file, maps columns, and clicks "Import". They can navigate away while a background job processes the file; notifications show when done.

##### Security Considerations

* Sanitize MDX to prevent XSS. Only allow whitelisted HTML tags and KaTeX.
* Validate that the moderator has rights to modify the question bank.
* Limit file upload size; restrict file types.
* Rate‑limit API endpoints for import to prevent abuse.

##### Testing Strategy

* Unit tests for Zod schema validation for question fields.
* Integration tests for API endpoints, ensuring versioning works.
* E2E tests for question creation/editing flows and bulk import wizard.
* Snapshot tests for MDX rendering to ensure KaTeX output consistent.

##### Data Management

* Use `pg_trgm` extension for similarity detection. Create GIN index on `body` column.
* Keep old versions for audit; optionally purge after a retention period.
* Use `question_banks` to group questions and assign ownership; cascade deletes.

##### Error Handling & Logging

* Provide descriptive errors for validation failures (e.g., "At least one correct answer required").
* Log duplicate detection results for analytics.
* In bulk import, capture row-level errors and return aggregated report.

---

### 4. Test‑Series & Practice

#### Feature goal

Enable moderators to bundle questions into timed practice tests (section‑wise or full‑length), set price or free, and allow students to attempt them in a realistic exam interface. Provide autosave, resume capability, scoring, percentile calculations and topic‑wise analytics.

#### API relationships

* Consumes questions from Question Authoring feature.
* Stores test definitions and attempts in the database.
* Interacts with analytics system to aggregate scores and compute percentiles.
* Payment integration (Razorpay) used if the test is paid.
* Real‑time updates via Socket.IO (e.g., for countdown timer broadcast).

#### Detailed feature requirements

1. **Test Creation**

   * Moderator selects questions by filter/tag/subject or individually.
   * Can create sections with independent time limits (optional).
   * Define test properties: title, description, price (0 for free), start/end window, max attempts per user, randomisation (shuffle questions).
   * Choose whether the test is scored as per GATE/PGEE (1‑mark and 2‑mark questions, negative marking).
   * Save as draft and publish when ready.

2. **Test Player (Student)**

   * Mirror official GATE interface: question palette, timer header, virtual calculator, instructions page, answer palette (answered, unanswered, flagged).
   * Autosave answers every X seconds; persist to DB.
   * Support MCQ, MSQ (multi‑select), NAT (numerical answer), and code‑snippet questions.
   * Resume incomplete attempts.
   * On submission or timeout, lock answers and compute score instantly.

3. **Scoring & Analytics**

   * After completion, show score, percentile (computed across all attempts), accuracy, speed (avg time per question), and topic‑wise heat map.
   * Allow review of answers and explanations (if enabled by moderator).
   * Record attempt data for analytics.

4. **Purchases**

   * If test is paid, student must purchase before attempt. Integrate with Razorpay; verify payment signature.

5. **Attempt Limits & Access Window**

   * Enforce start/end window (UTC) for availability.
   * Enforce max attempts; show countdown to next attempt if limited.

#### Detailed implementation guide

##### System Architecture Overview

* **Test Definition**: Stored in Postgres. Each test references a list of question IDs and order.
* **Test Player**: Implemented as a dynamic route under `/test-player/[testId]`. Uses Zustand for local exam state (current question index, answers). Timer uses `useEffect` and `setInterval`; persists remaining time to local storage.
* **Autosave Service**: Use `debounce` to send partial answers via API route every 15 seconds.
* **Submission**: At the end, call `/api/tests/:testId/submit` which records final answers and computes results. Score computation and percentile calculation happens server‑side in a transaction.
* **Analytics Worker**: Cron job aggregates scores to compute percentile and topic statistics; results stored in separate table for quick retrieval.

##### Database Schema Design

* **Tests** (`tests`):

  * `id` (UUID)
  * `title` (string)
  * `description` (text)
  * `moderator_id` (FK)
  * `price_cents` (integer)
  * `currency` (string, default 'INR')
  * `start_time` (timestamp)
  * `end_time` (timestamp)
  * `max_attempts` (integer)
  * `duration` (integer, seconds)
  * `randomize_questions` (boolean)
  * `status` (enum: 'draft', 'published', 'archived')
  * `created_at`, `updated_at`

* **TestSections** (`test_sections`): Optional sections: `id`, `test_id`, `name`, `duration_seconds`.

* **TestQuestions** (`test_questions`):

  * `id`
  * `test_id`
  * `question_id`
  * `section_id` (nullable)
  * `order` (integer)

* **TestPurchases** (`test_purchases`):

  * `id`
  * `test_id`
  * `student_id`
  * `payment_id` (Razorpay order ID)
  * `paid_at`
  * `amount`
  * `status` (enum: 'pending', 'paid', 'failed')

* **TestAttempts** (`test_attempts`):

  * `id`
  * `test_id`
  * `student_id`
  * `start_at`
  * `end_at`
  * `status` (enum: 'in\_progress', 'submitted', 'timed\_out')
  * `score` (float)
  * `percentile` (float)
  * `duration_seconds`
  * `created_at`, `updated_at`

* **TestAnswers** (`test_answers`):

  * `id`
  * `attempt_id`
  * `question_id`
  * `answer` (JSON)
  * `is_correct` (boolean)
  * `time_spent` (integer, seconds)

* **TestAnalytics** (`test_analytics`):

  * Pre‑computed aggregates: `test_id`, `question_id`, `correct_count`, `incorrect_count`, `avg_time`, `topic_accuracy`, `percentile_distribution` JSON, etc.

##### Comprehensive API Design

* **GET /api/tests**

  * Returns paginated tests visible to the user. Include filters (free/paid, subject, status).

* **GET /api/tests/\:id**

  * Returns test metadata and, if the user is authorised, the list of question stubs (without correct answers).
  * If status is draft or user is not authorised, return 403.

* **POST /api/tests**

  * Creates a new test definition. Body includes question IDs, duration, sections, price, window. Requires `create:test` permission.
  * Returns test ID.

* **PUT /api/tests/\:id**

  * Updates test definition; restricted to test owner or admin.

* **DELETE /api/tests/\:id**

  * Soft delete test (status = archived).

* **POST /api/tests/\:id/publish**

  * Publishes a draft test after validating it contains questions and is configured properly.

* **POST /api/tests/\:id/purchase**

  * Initiates payment via Razorpay; returns order ID and payment gateway options. Requires user logged in.
  * After payment, Razorpay calls webhook; server verifies signature and updates `test_purchases` status.

* **POST /api/tests/\:id/start**

  * Creates a `test_attempt` record if user has purchase or test is free and within window and attempts left. Returns attempt ID and test payload (question list).

* **PUT /api/tests/\:id/attempts/\:attemptId/answer**

  * Autosave or final save of answers. Body: `{ answers: [{ questionId, answer, timeSpent }], isSubmit }`.
  * If `isSubmit` is true, marks attempt as `submitted` or `timed_out`, computes score and percentiles.

* **GET /api/tests/\:id/attempts/\:attemptId/result**

  * Returns result summary with score, percentile, topic analysis, and answer explanations if allowed.

* **GET /api/tests/\:id/attempts/me**

  * Returns list of user’s attempts for this test with statuses.

##### Frontend Architecture

* **TestCreationWizard**: Stepper interface for moderators to define test details, choose questions via search/filter, set pricing and schedule.

* **TestListPage**: Displays list of available tests for students, with price tags and status (coming soon, available, closed).

* **TestPurchaseModal**: Shows price and payment options; calls `/api/tests/:id/purchase`.

* **TestPlayer**:

  * `ExamHeader`: timer, test title, progress.
  * `QuestionPalette`: shows status (answered, unanswered, flagged). Click to jump to question.
  * `QuestionViewer`: renders question MDX, options, answer input, flag toggle.
  * `Footer`: navigation (Next, Previous), Save & Submit.
  * `SummaryModal`: appears when time expires or user clicks submit; confirms final submission.

* **ResultPage**: Displays score, percentile, chart of topic performance using Chart.js via `react-chartjs-2`.

* **State Management**: Use Zustand store (`useExamStore`) to keep exam state. Persist partial answers to local storage in case of reload.

##### Detailed CRUD Operations

* *Tests*

  * **Create**: Validate at least one question; price ≥0; start time < end time; duration >0. Insert into `tests`, `test_sections`, `test_questions`.
  * **Read**: If user is a moderator, they can view draft tests; students only see published tests within window.
  * **Update**: Only before publishing. After publish, only description and schedule can be updated.
  * **Delete**: Soft delete; remove from listings; if attempts exist, cannot hard delete.

* *Attempts*

  * **Create**: On start, create attempt record, set start time; attach randomised question order if randomization enabled.
  * **Read**: Only attempt owner or moderator can view attempts.
  * **Update**: During test, update answers. On submit, compute results.
  * **Delete**: Admin can delete attempts; cascade delete answers.

##### User Experience Flow

* Student browses tests; selects one. If free, clicks "Start Test"; if paid, clicks "Buy", completes payment, then starts.
* When starting, a modal shows instructions and rules. On confirm, test begins and timer starts.
* Student navigates through questions; flags uncertain ones; autosaves responses.
* When time expires or user clicks submit, test ends and summary screen displays results.
* Student can review each question with correct answer and explanation if allowed.
* Student can attempt again if attempts remain and within window.

##### Security Considerations

* Prevent early access to answers by never sending correct answers to the client until submission.
* Use server‑side timer verification; client timer is for UX only.
* Ensure payments validated via Razorpay signature verification; call Razorpay API via secret key.
* Rate‑limit test start and answer submissions.
* Protect against tampering: on autosave, verify attempt ID belongs to user; verify question IDs belong to test.

##### Testing Strategy

* Unit tests: scoring algorithm for different question types; randomization logic.
* Integration tests: test start and submission endpoints with various edge cases (window expired, no attempts left).
* E2E tests: simulate a full test attempt, autosave/resume, and final scoring.
* Performance: load test to ensure the player can handle hundreds of concurrent connections; compute scoring within 500 ms.

##### Data Management

* Use indexes on `test_id`, `student_id` in `test_attempts` for quick lookup.
* Retain attempts for analytics; summarise data in `test_analytics` to avoid heavy queries.
* Archive expired tests (status `archived`) and hide from listings.

##### Error Handling & Logging

* Provide clear errors (e.g., “Test not yet open”); handle race conditions when user tries to start after window closed.
* Log events (test started, ended) with user ID, test ID.
* Use Sentry to capture unhandled exceptions in test player.

---

### 5. Analytics & Reporting

#### Feature goal

Provide students with detailed feedback on their performance (accuracy, speed, percentile, weak topics) and moderators/admins with cohort‑level statistics, revenue reports, and exportable data. Support scheduled email reports.

#### API relationships

* Reads data from `test_attempts`, `test_answers`, and `test_analytics`.
* Writes aggregated metrics to `test_analytics` and caches heavy computations in Redis.
* Sends reports via BullMQ jobs using worker.
* Exposes endpoints for front‑end dashboards and CSV/Excel exports.

#### Detailed feature requirements

1. **Student Analytics**

   * After each test, show personal score, percentile, accuracy per subject/topic, average time per question, and charts comparing with cohort.
   * Provide trends across multiple attempts (e.g., improvement over time).
   * Allow export of personal results as PDF.

2. **Moderator/Admin Analytics**

   * View aggregate performance of tests: average score, distribution histogram, hardest/easiest questions, drop‑off rates.
   * Filter by date range, subject, or cohort (e.g., branch/college if provided via profile).
   * Export data as CSV/Excel for offline analysis.
   * Schedule weekly or monthly email reports summarising revenue (from purchases) and participation.

3. **Real‑time Leaderboard**

   * Display leaderboard of top students by points or scores.
   * Filter by branch/college or subject.
   * Update in real time via Socket.IO.

4. **Privacy & Anonymity**

   * Student analytics are aggregate and anonymised; only share percentile and distributions, not other students’ scores.
   * Optionally allow students to hide their identity on leaderboards.

#### Detailed implementation guide

##### System Architecture Overview

* **Analytics Processor**: Background job (BullMQ) triggered after each test submission. Aggregates answers, computes metrics (correct/incorrect counts, average time, percentile). Stores results in `test_analytics` and updates `leaderboards` in Redis.
* **API Layer**: Provides endpoints for retrieving analytics; caches results with TTL in Redis to reduce DB load.
* **Frontend Dashboards**: Charts built with `react-chartjs-2`. Use server components to fetch analytics data via API routes.
* **Email Scheduler**: Cron job runs daily/weekly to generate CSV summaries and send emails via SendGrid.

##### Database Schema Design

* **TestAnalytics** (see previous section) stores aggregated per test metrics.
* **Leaderboard** can be stored in Redis sorted sets: key `leaderboard:<testId>` with score as sorting value. Additional metadata stored in DB.
* **StudentTopicAnalytics**: Optional table storing per‑student per‑topic stats across all tests (topic\_id, student\_id, correct\_count, incorrect\_count, avg\_time).
* **Reports**: `reports` table storing generated report files and metadata (report type, generated\_at, download\_url).

##### Comprehensive API Design

* **GET /api/analytics/test/\:testId/student**

  * Authenticated; returns the requesting student’s performance summary for the specified test (score, percentile, topic breakdown).

* **GET /api/analytics/test/\:testId**

  * Moderator/Admin only; returns aggregate analytics for a test, including distributions.

* **GET /api/analytics/student/trends**

  * Returns a student's performance trend across multiple tests.

* **GET /api/analytics/leaderboard**

  * Query params: `testId`, `limit`, `filterBy`, `cursor`.
  * Returns sorted list of students with scores and ranks.

* **GET /api/reports**

  * Admin only; returns list of generated reports with download URLs.

* **POST /api/reports/generate**

  * Admin only; body: `{ type: 'revenue' | 'cohort' | 'performance', range: { from, to } }`.
  * Enqueues job to create a report; returns job ID.

* **POST /api/reports/schedule**

  * Admin only; sets up recurring report (weekly/monthly) via cron expression.

##### Frontend Architecture

* **Student Result Page**: Already described under test feature; includes charts for topic accuracy (bar chart) and percentile distribution (histogram).
* **Student Trend Page**: Shows line chart of scores over time; displays improvement in weak topics.
* **Moderator Test Analytics Page**: Table summarising each test; clicking a test opens detailed charts (score distribution, question difficulty distribution, attempts over time).
* **Admin Dashboard**: High‑level KPIs (total revenue, active students, tests created) and ability to schedule reports.
* **Leaderboard Component**: Displays top performers; auto‑updates via Socket.IO.

##### Detailed CRUD Operations

* *Reports*

  * **Create**: Generate on demand or scheduled. Store file in DigitalOcean Spaces; record metadata in `reports`.
  * **Read**: List reports; download via signed URL.
  * **Update/Delete**: Only for scheduled tasks; update cron or remove schedule.

##### User Experience Flow

* Student finishes test and immediately sees analytics. They can navigate to a "My Progress" page to view trends.
* Moderator opens analytics page; selects a test and sees aggregated metrics. They can export to CSV by clicking "Export".
* Admin sets up a weekly revenue report; receives email with attached CSV.

##### Security Considerations

* Restrict analytics endpoints to authorised roles (student can only see own results).
* Ensure exported files do not contain personal identifiers (anonymise user IDs).
* Use signed URLs for report downloads.
* Limit leaderboard to show only top N users and allow opt‑out for students.

##### Testing Strategy

* Unit tests for percentile calculation and chart data transformation.
* Integration tests for analytics API; ensure results match expected aggregates.
* E2E tests for analytics dashboards; verify charts render correctly.
* Performance tests: heavy queries should run within defined budgets.

##### Data Management

* Use materialised views or pre‑aggregated tables for expensive analytics (e.g., percentiles).
* Periodically clean up old analytics data if tests are archived.
* Use Redis sorted sets for leaderboards; update atomically.

##### Error Handling & Logging

* Provide fallback when analytics not yet computed (display "Processing...").
* Capture and log failures of analytics jobs; retry up to 5 times (exponential backoff).
* Notify moderators/admins if scheduled report generation fails.

---

### 6. Community & Gamification

#### Feature goal

Foster peer‑to‑peer learning by allowing students to discuss questions, earn points for correct explanations, and engage in leaderboards. Provide automatic spam detection and moderation tools. Implement gamification with badges, streaks, and leaderboard filtered by college/branch.

#### API relationships

* Comments and votes stored in DB; retrieval integrated with question pages.
* Points and badges updated via background jobs.
* Real‑time comment updates via Socket.IO.
* Spam detection can call an external ML service or use simple heuristics.

#### Detailed feature requirements

1. **Threaded Comments**

   * Students can comment under questions and replies (nested).
   * Comments can include markdown (limited) and LaTeX.
   * Students can upvote (or like) comments; correct answer accepted by moderator or community if threshold reached.
   * Sorting by "Top" (most upvotes) or "Newest".

2. **Gamification Points & Badges**

   * Points awarded for upvotes received, correct answer accepted, test completion streaks, daily login.
   * Badges earned at thresholds (e.g., "Top Contributor", "Streak Master").
   * Points can be spent on perks (e.g., unlocking hint or discount).

3. **Moderation**

   * Automatic spam detection using heuristic (length, link count, similarity). Comments above threshold go to moderation queue.
   * Students with ≥ X points can flag comments; ≥ Y can close threads; moderators can lock or delete.
   * Provide UI for moderators to review flagged items and take action.

4. **Leaderboard**

   * Display ranking by points; filter by branch/college; show top N.
   * Option for students to remain anonymous or use nickname.

#### Detailed implementation guide

##### System Architecture Overview

* **Comment Service**: API routes under `/api/comments`. Use Prisma to manage hierarchical structure via `parent_comment_id`.
* **Vote/Point System**: Use `votes` table for upvotes. Use triggers or background job to recalculate points and update `user_points` table.
* **Gamification Engine**: Cron job updates streaks, awards badges, recalculates leaderboards.
* **Spam Detector**: Either integrate a third‑party ML API or implement heuristics (e.g., comment length < 3 characters flagged; too many links flagged).
* **Socket.IO**: Use `io.to(room).emit` to broadcast new comments or updates to users viewing a question.

##### Database Schema Design

* **Comments** (`comments`):

  * `id` (UUID)
  * `question_id` (FK)
  * `author_id` (FK to users)
  * `parent_comment_id` (nullable FK to comments)
  * `body` (text, markdown)
  * `status` (enum: 'active', 'flagged', 'pending', 'deleted')
  * `spam_score` (float)
  * `created_at`, `updated_at`

* **Votes** (`votes`):

  * `id`
  * `comment_id`
  * `voter_id`
  * `value` (int; 1 for upvote)
  * `created_at`

* **UserPoints** (`user_points`):

  * `user_id`
  * `points` (int)
  * `streak` (int)
  * `last_login_at` (timestamp)

* **Badges** (`badges`):

  * `id`, `slug`, `name`, `description`, `points_required`, etc.

* **UserBadges** (`user_badges`):

  * `user_id`, `badge_id`, `awarded_at`

* **Flags** (`flags`):

  * `id`, `comment_id`, `flagger_id`, `reason`, `created_at`, `status`

##### Comprehensive API Design

* **POST /api/comments**

  * Body: `{ questionId, parentCommentId?, body }`.
  * Validates length, markdown; checks spam.
  * Saves with `status = 'pending'` if spam score high; else `active`.
  * Broadcasts via Socket.IO.

* **GET /api/comments/\:questionId**

  * Returns threaded comments for the question; supports pagination by parent thread.
  * Includes vote counts and user’s vote status.

* **POST /api/comments/\:id/vote**

  * Body: `{ value: 1 | -1 }`; toggles vote.
  * Updates `votes` and recalculates user points in background.

* **POST /api/comments/\:id/flag**

  * Students with enough points can flag; body includes `reason`.
  * Sets comment status to `flagged`; notifies moderators.

* **POST /api/moderation/comments/\:id**

  * Moderator actions: `{ action: 'approve' | 'delete' | 'ban' }`.
  * Approve sets status to `active`; delete marks comment as `deleted`; ban may restrict user.

* **GET /api/leaderboard**

  * Query params: `branch`, `college`, `limit`.
  * Returns top users with points and badges.

##### Frontend Architecture

* **CommentThread** component: recursively renders comments and children; includes upvote button and flag button.
* **CommentForm**: Markdown editor with preview; uses `react-hook-form`.
* **GamificationBadge**: Shows badges on user profile and leaderboard.
* **ModerationDashboard**: For moderators to review flagged comments.
* **LeaderboardPage**: Shows filters and ranking; uses infinite scroll or pagination.

##### Detailed CRUD Operations

* *Comments*

  * **Create**: Validate markdown; compute spam score; insert record.
  * **Read**: Query by question; return nested threads with votes.
  * **Update**: Only author or moderator can edit; maintain edit history.
  * **Delete**: Soft delete; mark as deleted; do not remove from DB to maintain thread context.

* *Votes*

  * **Create/Update**: Upvoting toggles entry; update or insert `votes`.
  * **Delete**: Removing upvote deletes record.

* *Flags*

  * **Create**: Students create flag; increments `flags` count; triggers moderation queue.
  * **Update**: Moderator updates status.
  * **Delete**: Remove flag when resolved.

##### User Experience Flow

* User reads a question and sees existing comments; they can reply or upvote.
* When posting a comment, they type in markdown; preview updates; clicking "Submit" sends to server. If comment flagged as spam, it appears only after moderator approval.
* Upvoting increments points for the comment author.
* As points accumulate, badges appear on the user’s profile; leaderboards show ranking.
* Moderator dashboard shows flagged comments; moderators approve or delete.

##### Security Considerations

* Rate‑limit comment creation and upvotes to prevent spam.
* Sanitize markdown to allow only safe tags (e.g., `<strong>`, `<em>`, `<code>`) and KaTeX.
* Prevent CSRF on comment and vote endpoints; use NextAuth session tokens.
* Ensure user cannot upvote their own comment multiple times.

##### Testing Strategy

* Unit tests for spam detection function; markdown sanitization.
* Integration tests for comment creation, voting, and moderation actions.
* E2E tests for threaded comments UI and gamification flows.

##### Data Management

* Maintain comment counts and votes counts in question table for quick display.
* Periodically archive old comments if questions archived.
* Use caching for leaderboard queries; update when points change.

##### Error Handling & Logging

* Return helpful errors (e.g., “Comment too short”).
* Log flagged comments and moderation actions for audit.
* Notify moderators via in‑app notifications when flagged items accumulate.

---

### 7. Payments & E‑commerce

#### Feature goal

Integrate Razorpay Standard Checkout for paid test‑series. Allow moderators to set fixed prices, apply coupons, and generate GST‑compliant invoices. Verify payment signatures and handle webhooks securely.

#### API relationships

* Calls Razorpay’s Orders API to create orders and verify payment signatures.
* Stores orders, transactions, and invoices in Postgres.
* Uses background worker to send invoice emails.
* Interacts with test creation module to mark tests as purchased.

#### Detailed feature requirements

1. **Product Catalog**

   * Tests (or packs) can be priced individually. Admin can also create bundles containing multiple tests.
   * Admin can set limited‑time offers or coupons (percentage or fixed discount).

2. **Checkout Flow**

   * Student initiates purchase; server creates a Razorpay order with amount, currency, receipt.
   * Client loads Razorpay checkout script and collects payment details.
   * On payment completion, Razorpay calls a webhook; server verifies signature and marks purchase as paid.

3. **Invoices**

   * After payment success, generate invoice with GST breakdown and unique invoice number.
   * Send PDF invoice via email to student; store invoice details.
   * Admin can download invoice via dashboard.

4. **Refunds & Failed Payments**

   * Provide admin tools to initiate refunds via Razorpay API.
   * Handle payment failures; allow retry.

5. **Coupons & Offers**

   * Admin can create coupons with code, discount type, expiry, usage limit.
   * Students apply coupon at checkout; server verifies and adjusts order amount.

#### Detailed implementation guide

##### System Architecture Overview

* **Orders API**: Expose `/api/payments/create-order` which accepts `testId` and optional `couponCode`. Validates eligibility, calculates amount, calls Razorpay Orders API using secret key. Returns order ID.
* **Webhook Handler**: `/api/payments/webhook` receives events (`payment.captured`, `payment.failed`). Verify signature using Razorpay secret; update `test_purchases` and create `transactions` record.
* **Invoice Generator**: Use a Node library like `pdfkit` to create PDF invoices. Run in worker to avoid blocking.
* **Coupon Service**: API routes to create/update/delete coupons; apply coupon logic in checkout flow.

##### Database Schema Design

* **TestPurchases** (see earlier) holds purchase records.

* **Transactions** (`transactions`):

  * `id`, `purchase_id`, `razorpay_order_id`, `razorpay_payment_id`, `status`, `amount`, `currency`, `payment_method`, `captured_at`.

* **Coupons** (`coupons`):

  * `id`, `code` (string, unique), `discount_type` (enum: 'percentage', 'fixed'), `discount_value`, `expiry_date`, `usage_limit`, `used_count`, `applicable_test_id` (nullable), `created_at`.

* **Invoices** (`invoices`):

  * `id`, `purchase_id`, `invoice_number`, `file_url`, `gst_number`, `created_at`.

##### Comprehensive API Design

* **POST /api/payments/create-order**

  * Body: `{ testId, couponCode }`.
  * Validates user hasn’t purchased test; test is published and available.
  * Calculates final amount considering coupon; creates Razorpay order via API and returns order details to client.

* **POST /api/payments/verify**

  * After payment on client, call this API with `{ razorpayPaymentId, razorpayOrderId, razorpaySignature, testId }`.
  * Server verifies signature; if valid, updates `test_purchases` status to `paid`; initiates invoice generation job.

* **POST /api/payments/webhook**

  * Receives events; verifies signature; updates corresponding records. Must handle asynchronous events like refund.

* **POST /api/coupons**

  * Admin creates coupon; body includes details.
  * Validates uniqueness; returns coupon.

* **PUT /api/coupons/\:id** and **DELETE /api/coupons/\:id**.

* **GET /api/invoices/\:purchaseId**

  * Returns signed download URL for invoice PDF.

##### Frontend Architecture

* **CheckoutModal**: When purchasing a test, display order summary and input for coupon code. On clicking Pay, call `create-order`, then open Razorpay checkout using the returned order ID.
* **PaymentResultPage**: After payment, call `/api/payments/verify` via client action; show success/failure message.
* **CouponsAdminPage**: Form to create and list coupons; allow editing or deleting.
* **InvoiceLink**: On user’s purchase history, show a link to download invoice once available.

##### Detailed CRUD Operations

* *Coupons*

  * **Create**: Validate code is unique and expiry date > now. Insert into DB.
  * **Read**: List active coupons; filter by test.
  * **Update**: Update discount, expiry, usage limit.
  * **Delete**: Soft delete; do not allow deletion if already used.

* *Transactions*

  * **Create**: On successful payment or refund event, record transaction details.
  * **Read**: Admin can view transaction history by test or user.

##### User Experience Flow

* Student selects a paid test; modal shows price and coupon field. They enter coupon (if any).
* On "Pay", server returns order; Razorpay opens; user completes payment.
* On success, client calls verify API; user sees "Payment successful" and can start test.
* Later, they can download invoice from purchase history.
* If payment fails, user sees error and can retry.

##### Security Considerations

* Store Razorpay secret keys securely in environment variables; never expose to client.
* Verify Razorpay webhook signatures; restrict webhook route to Razorpay IP addresses if possible.
* Rate‑limit coupon attempts to prevent brute force.
* Ensure invoice numbers are sequential and unique.

##### Testing Strategy

* Unit tests for coupon calculation logic and signature verification.
* Integration tests mocking Razorpay API; test order creation and webhook handling.
* E2E tests for full purchase flow.
* Security tests to ensure webhook cannot be forged.

##### Data Management

* Keep transaction logs for audits.
* Archive old invoices to cheaper storage after a period.
* Track coupon usage to enforce limits.

##### Error Handling & Logging

* Return meaningful errors (e.g., “Coupon expired”).
* Log failed payments with reason.
* Notify admin if webhook verification fails.

---

### 8. Adaptive Test Generator & Personalisation (Post‑MVP)

#### Feature goal

After MVP, provide an adaptive engine that generates personalised tests based on student’s weak topics and past performance, and use GPT‑assisted explanation drafts for moderators.

#### API relationships

* Utilises analytics data to determine weak topics.
* Calls AI models (e.g., OpenAI or local LLM) to generate question explanations.
* Interacts with question authoring system to create new questions.

#### Detailed feature requirements

1. **Adaptive Test Generator**

   * An algorithm selects questions that target a student’s weakest topics.
   * Generate tests of specified length and difficulty distribution.
   * Adjust difficulty dynamically based on real‑time performance (adaptive testing).

2. **GPT‑assisted Explanations**

   * When moderators draft explanations, provide AI suggestions based on question body and correct answer.
   * Moderators can edit suggestions before publishing.
   * Log AI usage for accountability.

#### Detailed implementation guide

##### System Architecture Overview

* **Recommendation Engine**: Resides in worker; uses analytics tables to pick questions by tag difficulty. Could implement Item Response Theory (IRT) or simpler heuristics initially.
* **AI Integration**: Use an API (e.g., OpenAI) with streaming responses. Provide server route `/api/ai/explanation` which calls the model and streams output to client.
* **UI**: On moderator’s question editor, show a "Generate Explanation" button; call AI endpoint and insert suggestion into explanation field.

##### Database Schema Design

* **AdaptiveSessions** (`adaptive_sessions`):

  * `id`, `student_id`, `started_at`, `current_question_id`, `remaining_questions`, `session_data` JSON.

* **AIUsageLogs** (`ai_usage_logs`):

  * `id`, `user_id`, `feature` (e.g., explanation), `tokens_used`, `cost`, `timestamp`.

##### Comprehensive API Design

* **POST /api/adaptive-tests/start**

  * Body: `{ topicIds, numQuestions, difficultyDistribution }`; returns session ID and first question.

* **POST /api/adaptive-tests/\:sessionId/answer**

  * Body: `{ questionId, answer, timeSpent }`; server updates session state and returns next question or finish result.

* **POST /api/ai/explanation**

  * Body: `{ questionBody, correctAnswer }`; server calls AI model and streams explanation.

##### Frontend Architecture

* Adaptive test player similar to normal test player but fetches questions one by one based on server decisions.
* Explanation assistant integrated into question editor UI.

##### Considerations

* Ensure cost control by limiting AI usage; require moderator confirmation.
* Provide fallback if AI fails.
* Data privacy: do not send personal data to AI service.

---

### Interactions Between Features

* **Account & Identity ↔ RBAC**: On login, user’s role determines their CASL abilities. The frontend uses `useAbility` to enable or disable UI elements accordingly.
* **RBAC ↔ Question/Test/Analytics**: Each CRUD operation checks the user’s permissions before proceeding. For instance, only moderators with `create:test` can create tests. Analytics endpoints restrict access to the student’s own data or require `view:analytics` permission.
* **Question Authoring ↔ Test Series**: Tests reference questions; do not allow deletion or modification of questions that are part of published tests. Use database constraints and CASL conditions to enforce.
* **Community ↔ Gamification ↔ Analytics**: Points from community interactions influence leaderboards displayed in Analytics/Community pages. Use common `user_points` table.
* **Payments ↔ Tests**: Payment status controls access to paid tests. Payment verification updates `test_purchases`, and Test player checks this before starting an attempt.
* **Analytics ↔ Adaptive Test Generator**: Adaptive engine uses analytics data to determine weak topics; an additional job regularly summarises student performance by topic.
* **AI Explanations ↔ Question Authoring**: AI suggestions are an optional assist; moderators still need `create:question` permission to publish.

Each feature must consider the others during implementation to avoid circular dependencies and maintain a coherent user experience.
